{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///B:/projects/gaurav-new/components/market/market-context.tsx"],"sourcesContent":["\"use client\"\r\n\r\nimport React, { createContext, useContext, useMemo, useState, useEffect, useRef, useCallback } from 'react'\r\nimport { io, Socket } from 'socket.io-client'\r\n\r\ntype MarketSymbolData = {\r\n  ltp?: number\r\n  token?: number\r\n  exchange?: string\r\n  timestamp?: string\r\n  lot_size?: number\r\n  low?: number\r\n  high?: number\r\n  open?: number\r\n  close?: number\r\n  atp?: number\r\n  volume?: number\r\n  oi?: number\r\n  percentChange?: number\r\n  netChange?: number\r\n  depth?: any\r\n}\r\n\r\ntype TokenInput = string | number | { token: string | number; symbol?: string; exchange?: string }\r\n\r\ntype MarketState = {\r\n  symbols: Record<string, MarketSymbolData>\r\n  connected: boolean\r\n  // Components can request live updates for specific contracts/symbols\r\n  subscribeTokens?: (tokens: TokenInput[]) => void\r\n}\r\n\r\nconst MarketContext = createContext<MarketState | null>(null)\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5000'\r\nconst API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000'\r\n\r\n// Default tokens will be fetched dynamically from API when needed\r\n// These are just placeholder keys - actual tokens come from database when symbol is selected\r\nconst DEFAULT_TOKENS: TokenInput[] = []\r\n\r\nexport function MarketProvider({ children }: { children: React.ReactNode }) {\r\n  const [store, setStore] = useState<Record<string, MarketSymbolData>>({})\r\n  const [connected, setConnected] = useState(false)\r\n  const socketRef = useRef<Socket | null>(null)\r\n  const pendingTokensRef = useRef<Set<string>>(new Set())\r\n  const tokenMetaRef = useRef<Map<string, { exchange: string; symbol?: string }>>(new Map())\r\n  const defaultsRegisteredRef = useRef(false)\r\n  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null)\r\n  const isPollingRef = useRef(false)\r\n\r\n  // Use refs to avoid dependency issues\r\n  const storeRef = useRef(store)\r\n  useEffect(() => {\r\n    storeRef.current = store\r\n  }, [store])\r\n\r\n  const emitPendingSubscriptions = useCallback(() => {\r\n    if (!socketRef.current || !socketRef.current.connected || pendingTokensRef.current.size === 0) return\r\n    const payload = Array.from(pendingTokensRef.current).map(key => {\r\n      const [exchange, token] = key.split(':')\r\n      const meta = tokenMetaRef.current.get(key)\r\n      const symbol = meta?.symbol\r\n      return {\r\n        exchange,\r\n        token,\r\n        symbol,\r\n        symbolName: symbol,\r\n      }\r\n    })\r\n    try {\r\n      socketRef.current.emit('subscribePositions', { brokerId: 'market', tokens: payload, updateInterval: 5 })\r\n      console.log('Market: emitted subscribePositions for tokens', payload)\r\n    } catch (e) {\r\n      console.error('Market: failed to emit subscribePositions', e)\r\n    }\r\n  }, [])\r\n\r\n  const syncFullQuotes = useCallback(async (tokenList: Array<{ exchange: string; token: string }>) => {\r\n    if (!tokenList || tokenList.length === 0) return\r\n\r\n    // Deduplicate tokens per exchange\r\n    const dedupMap = new Map<string, { exchange: string; token: string }>()\r\n    tokenList.forEach(item => {\r\n      if (!item?.token) return\r\n      const exchange = (item.exchange || 'NSE').toUpperCase()\r\n      const key = `${exchange}:${item.token}`\r\n      dedupMap.set(key, { exchange, token: String(item.token) })\r\n    })\r\n\r\n    if (dedupMap.size === 0) return\r\n\r\n    try {\r\n      const response = await fetch(`${API_BASE}/api/quotes/full`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ tokens: Array.from(dedupMap.values()) })\r\n      })\r\n      const json = await response.json()\r\n      if (!json?.success || !Array.isArray(json.data)) return\r\n\r\n      setStore(prev => {\r\n        const copy: Record<string, MarketSymbolData> = { ...prev }\r\n        json.data.forEach((quote: any) => {\r\n          if (!quote) return\r\n          const exchange = (quote.exchange || 'NSE').toUpperCase()\r\n          const token = quote.token ? String(quote.token) : undefined\r\n          const keyId = token ? `${exchange}:${token}` : undefined\r\n          const meta = keyId ? tokenMetaRef.current.get(keyId) : undefined\r\n          const symbolKey = meta?.symbol || quote.symbol || (token ? `Token_${token}` : undefined)\r\n          if (!symbolKey) return\r\n\r\n          console.log(`[MarketContext] ðŸ“Š Full quote for key=\"${symbolKey}\" token=${token}: LTP=${quote.ltp}, low=${quote.low}, high=${quote.high}`)\r\n\r\n          copy[symbolKey] = {\r\n            ...(copy[symbolKey] || {}),\r\n            ltp: quote.ltp ?? copy[symbolKey]?.ltp,\r\n            token: token ? Number(token) : copy[symbolKey]?.token,\r\n            exchange,\r\n            timestamp: quote.timestamp || new Date().toISOString(),\r\n            low: quote.low ?? copy[symbolKey]?.low,\r\n            high: quote.high ?? copy[symbolKey]?.high,\r\n            open: quote.open ?? copy[symbolKey]?.open,\r\n            close: quote.close ?? copy[symbolKey]?.close,\r\n            atp: quote.atp ?? copy[symbolKey]?.atp,\r\n            volume: quote.volume ?? copy[symbolKey]?.volume,\r\n            oi: quote.oi ?? copy[symbolKey]?.oi,\r\n            percentChange: quote.percentChange ?? copy[symbolKey]?.percentChange,\r\n            netChange: quote.netChange ?? copy[symbolKey]?.netChange,\r\n            depth: quote.depth ?? copy[symbolKey]?.depth,\r\n            lot_size: copy[symbolKey]?.lot_size,\r\n          }\r\n        })\r\n        console.log('[MarketContext] ðŸ“Š After full quote sync, total keys:', Object.keys(copy).length)\r\n        return copy\r\n      })\r\n    } catch (error) {\r\n      console.error('Market: unable to sync full quotes', error)\r\n    }\r\n  }, [])\r\n\r\n  // Poll for quotes at regular intervals to ensure real-time updates\r\n  const startPolling = useCallback(() => {\r\n    // Avoid starting multiple polling loops\r\n    if (isPollingRef.current) return\r\n    isPollingRef.current = true\r\n    \r\n    // Clear any existing polling\r\n    if (pollingIntervalRef.current) {\r\n      clearInterval(pollingIntervalRef.current)\r\n    }\r\n    \r\n    // Poll every 2 seconds for live data (reduced frequency to avoid overload)\r\n    pollingIntervalRef.current = setInterval(() => {\r\n      if (pendingTokensRef.current.size === 0) return\r\n      \r\n      const tokenList = Array.from(pendingTokensRef.current).map(key => {\r\n        const [exchange, token] = key.split(':')\r\n        return { exchange, token }\r\n      })\r\n      \r\n      // Only sync quotes, don't re-emit subscriptions every interval\r\n      syncFullQuotes(tokenList)\r\n    }, 2000) // Poll every 2 seconds\r\n    \r\n    console.log('[MarketContext] ðŸ”„ Started polling for real-time updates')\r\n  }, [syncFullQuotes])\r\n\r\n  const stopPolling = useCallback(() => {\r\n    isPollingRef.current = false\r\n    if (pollingIntervalRef.current) {\r\n      clearInterval(pollingIntervalRef.current)\r\n      pollingIntervalRef.current = null\r\n      console.log('[MarketContext] â¹ï¸ Stopped polling')\r\n    }\r\n  }, [])\r\n\r\n  const subscribeTokens = useCallback((tokens: TokenInput[]) => {\r\n    try {\r\n      if (!Array.isArray(tokens) || tokens.length === 0) return\r\n\r\n      console.log('[MarketContext] ðŸ“ subscribeTokens called with:', tokens)\r\n\r\n      const formatted = tokens\r\n        .map(token => {\r\n          if (token == null) return null\r\n          if (typeof token === 'object' && 'token' in token) {\r\n            return {\r\n              token: String(token.token),\r\n              exchange: (token.exchange || 'NSE').toUpperCase(),\r\n              symbol: token.symbol,\r\n            }\r\n          }\r\n          return { token: String(token), exchange: 'NSE' }\r\n        })\r\n        .filter(Boolean) as Array<{ token: string; exchange: string; symbol?: string }>\r\n\r\n      if (formatted.length === 0) return\r\n\r\n      console.log('[MarketContext] ðŸ“ Formatted tokens for subscription:', formatted)\r\n\r\n      formatted.forEach(({ token, exchange, symbol }) => {\r\n        const key = `${exchange}:${token}`\r\n        pendingTokensRef.current.add(key)\r\n        tokenMetaRef.current.set(key, { exchange, symbol })\r\n        console.log(`[MarketContext] Added to pending: ${key} -> ${symbol}`)\r\n      })\r\n\r\n      emitPendingSubscriptions()\r\n      syncFullQuotes(formatted.map(({ exchange, token }) => ({ exchange, token })))\r\n      \r\n      // Start polling for continuous updates (only starts once)\r\n      startPolling()\r\n    } catch (error) {\r\n      console.error('Market: failed to subscribe tokens', error)\r\n    }\r\n  }, []) // Empty deps - use refs for any mutable state\r\n\r\n  useEffect(() => {\r\n    // Connect to backend Socket.IO server\r\n    try {\r\n      const socket = io(SOCKET_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        autoConnect: true,\r\n        reconnectionAttempts: Infinity,\r\n        reconnectionDelay: 2000\r\n      })\r\n      socketRef.current = socket\r\n\r\n      socket.on('connect', () => {\r\n        setConnected(true)\r\n        console.log('Market: connected to position WebSocket server')\r\n        emitPendingSubscriptions()\r\n      })\r\n\r\n      socket.on('disconnect', (reason: any) => {\r\n        setConnected(false)\r\n        console.log('Market: disconnected from position WebSocket server', reason)\r\n      })\r\n\r\n      socket.on('positionUpdate', (payload: any) => {\r\n        try {\r\n          const positions = payload?.positions || []\r\n          if (positions.length === 0) return\r\n          \r\n          // Debug: show incoming positions for troubleshooting\r\n          console.log('[MarketContext] ðŸ“¡ positionUpdate received:', {\r\n            positionsCount: positions.length,\r\n            sample: positions.slice(0, 2),\r\n          })\r\n          \r\n          // positions are expected to be parsed market ticks forwarded from backend\r\n          // Example item: { symbol: 'NIFTY 50', token: 26000, ltp: 21123.45, timestamp: '...' }\r\n          setStore(prev => {\r\n            let hasChanges = false\r\n            const copy = { ...prev }\r\n            \r\n            for (const p of positions) {\r\n              const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString()\r\n              const existing = copy[key]\r\n              const newLtp = p.ltp != null ? Number(p.ltp) : existing?.ltp\r\n              \r\n              // Only update if there's actually new data\r\n              if (newLtp !== existing?.ltp || !existing) {\r\n                hasChanges = true\r\n                copy[key] = {\r\n                  ...(existing || {}),\r\n                  ltp: newLtp,\r\n                  token: p.token != null ? Number(p.token) : existing?.token,\r\n                  timestamp: p.timestamp || new Date().toISOString(),\r\n                  low: p.low ?? existing?.low,\r\n                  high: p.high ?? existing?.high,\r\n                  open: p.open ?? existing?.open,\r\n                  close: p.close ?? existing?.close,\r\n                  oi: p.oi ?? existing?.oi,\r\n                  percentChange: p.percentChange ?? p.changePercent ?? existing?.percentChange,\r\n                  netChange: p.netChange ?? p.change ?? existing?.netChange,\r\n                  depth: p.depth ?? existing?.depth,\r\n                  volume: p.volume ?? existing?.volume,\r\n                  lot_size: p.lot_size || existing?.lot_size\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Only return new object if there are actual changes\r\n            return hasChanges ? copy : prev\r\n          })\r\n        } catch (e) {\r\n          console.error('Market: failed to handle positionUpdate', e)\r\n        }\r\n      })\r\n\r\n      socket.on('initialPositions', (payload: any) => {\r\n        try {\r\n          const positions = payload?.positions || []\r\n          const map: Record<string, any> = {}\r\n          for (const p of positions) {\r\n            const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString()\r\n            map[key] = {\r\n              ltp: p.ltp != null ? Number(p.ltp) : undefined,\r\n              token: p.token != null ? Number(p.token) : undefined,\r\n              timestamp: p.timestamp || new Date().toISOString(),\r\n              low: p.low,\r\n              high: p.high,\r\n              open: p.open,\r\n              close: p.close,\r\n              oi: p.oi,\r\n              percentChange: p.percentChange ?? p.changePercent,\r\n              netChange: p.netChange ?? p.change,\r\n              depth: p.depth,\r\n              volume: p.volume,\r\n            }\r\n          }\r\n          setStore(prev => ({ ...prev, ...map }))\r\n          // Debug: load initial map into window variable for inspection\r\n          try { (window as any)._marketSymbolsDebug = map } catch (e) {}\r\n        } catch (e) {\r\n          console.error('Market: failed to handle initialPositions', e)\r\n        }\r\n      })\r\n\r\n      socket.on('connect_error', (err: any) => {\r\n        console.error('Market: socket connect_error', err)\r\n        setConnected(false)\r\n      })\r\n\r\n      return () => {\r\n        try {\r\n          socket.off('positionUpdate')\r\n          socket.off('initialPositions')\r\n          socket.disconnect()\r\n          // Stop polling on cleanup\r\n          if (pollingIntervalRef.current) {\r\n            clearInterval(pollingIntervalRef.current)\r\n            pollingIntervalRef.current = null\r\n          }\r\n        } catch (e) {}\r\n      }\r\n    } catch (e) {\r\n      console.error('Market: failed to initialize socket', e)\r\n    }\r\n  }, [])\r\n\r\n  // Register defaults once after mount\r\n  useEffect(() => {\r\n    if (!defaultsRegisteredRef.current && DEFAULT_TOKENS.length > 0) {\r\n      defaultsRegisteredRef.current = true\r\n      subscribeTokens(DEFAULT_TOKENS)\r\n    }\r\n  }, []) // Run only once on mount\r\n  \r\n  // Cleanup polling on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingIntervalRef.current) {\r\n        clearInterval(pollingIntervalRef.current)\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  // Use a stable reference for subscribeTokens\r\n  const subscribeTokensRef = useRef(subscribeTokens)\r\n  subscribeTokensRef.current = subscribeTokens\r\n\r\n  const stableSubscribeTokens = useCallback((tokens: TokenInput[]) => {\r\n    subscribeTokensRef.current(tokens)\r\n  }, [])\r\n\r\n  const state = useMemo(\r\n    () => ({ symbols: store, connected, subscribeTokens: stableSubscribeTokens }),\r\n    [store, connected, stableSubscribeTokens],\r\n  )\r\n\r\n  return <MarketContext.Provider value={state}>{children}</MarketContext.Provider>\r\n}\r\n\r\nexport function useMarket() {\r\n  const ctx = useContext(MarketContext)\r\n  if (!ctx) throw new Error('useMarket must be used within MarketProvider')\r\n  return ctx\r\n}\r\n"],"names":[],"mappings":"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"}}]
}