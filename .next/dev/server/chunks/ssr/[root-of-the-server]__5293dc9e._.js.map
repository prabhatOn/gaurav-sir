{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///B:/projects/gaurav-new/components/market/market-context.tsx"],"sourcesContent":["\"use client\"\r\n\r\nimport React, { createContext, useContext, useMemo, useState, useEffect, useRef, useCallback } from 'react'\r\nimport { io, Socket } from 'socket.io-client'\r\n\r\ntype MarketSymbolData = {\r\n  ltp?: number\r\n  token?: number\r\n  exchange?: string\r\n  timestamp?: string\r\n  lot_size?: number\r\n  low?: number\r\n  high?: number\r\n  open?: number\r\n  close?: number\r\n  atp?: number\r\n  volume?: number\r\n  oi?: number\r\n  percentChange?: number\r\n  netChange?: number\r\n  depth?: any\r\n}\r\n\r\ntype TokenInput = string | number | { token: string | number; symbol?: string; exchange?: string }\r\n\r\ntype MarketState = {\r\n  symbols: Record<string, MarketSymbolData>\r\n  connected: boolean\r\n  // Components can request live updates for specific contracts/symbols\r\n  subscribeTokens?: (tokens: TokenInput[]) => void\r\n}\r\n\r\nconst MarketContext = createContext<MarketState | null>(null)\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5000'\r\nconst API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000'\r\n\r\n// Default tokens will be fetched dynamically from API when needed\r\n// These are just placeholder keys - actual tokens come from database when symbol is selected\r\nconst DEFAULT_TOKENS: TokenInput[] = []\r\n\r\nexport function MarketProvider({ children }: { children: React.ReactNode }) {\r\n  const [store, setStore] = useState<Record<string, MarketSymbolData>>({})\r\n  const [connected, setConnected] = useState(false)\r\n  const socketRef = useRef<Socket | null>(null)\r\n  const pendingTokensRef = useRef<Set<string>>(new Set())\r\n  const tokenMetaRef = useRef<Map<string, { exchange: string; symbol?: string }>>(new Map())\r\n  const defaultsRegisteredRef = useRef(false)\r\n  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null)\r\n  const isPollingRef = useRef(false)\r\n\r\n  // Use refs to avoid dependency issues\r\n  const storeRef = useRef(store)\r\n  useEffect(() => {\r\n    storeRef.current = store\r\n  }, [store])\r\n\r\n  const emitPendingSubscriptions = useCallback(() => {\r\n    if (!socketRef.current || !socketRef.current.connected || pendingTokensRef.current.size === 0) return\r\n    const payload = Array.from(pendingTokensRef.current).map(key => {\r\n      const [exchange, token] = key.split(':')\r\n      const meta = tokenMetaRef.current.get(key)\r\n      const symbol = meta?.symbol\r\n      return {\r\n        exchange,\r\n        token,\r\n        symbol,\r\n        symbolName: symbol,\r\n      }\r\n    })\r\n    try {\r\n      socketRef.current.emit('subscribePositions', { brokerId: 'market', tokens: payload, updateInterval: 5 })\r\n      console.log('Market: emitted subscribePositions for tokens', payload)\r\n    } catch (e) {\r\n      console.error('Market: failed to emit subscribePositions', e)\r\n    }\r\n  }, [])\r\n\r\n  const syncFullQuotes = useCallback(async (tokenList: Array<{ exchange: string; token: string }>) => {\r\n    if (!tokenList || tokenList.length === 0) return\r\n\r\n    // Deduplicate tokens per exchange\r\n    const dedupMap = new Map<string, { exchange: string; token: string }>()\r\n    tokenList.forEach(item => {\r\n      if (!item?.token) return\r\n      const exchange = (item.exchange || 'NSE').toUpperCase()\r\n      const key = `${exchange}:${item.token}`\r\n      dedupMap.set(key, { exchange, token: String(item.token) })\r\n    })\r\n\r\n    if (dedupMap.size === 0) return\r\n\r\n    try {\r\n      const response = await fetch(`${API_BASE}/api/quotes/full`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ tokens: Array.from(dedupMap.values()) })\r\n      })\r\n      const json = await response.json()\r\n      if (!json?.success || !Array.isArray(json.data)) return\r\n\r\n      setStore(prev => {\r\n        const copy: Record<string, MarketSymbolData> = { ...prev }\r\n        json.data.forEach((quote: any) => {\r\n          if (!quote) return\r\n          const exchange = (quote.exchange || 'NSE').toUpperCase()\r\n          const token = quote.token ? String(quote.token) : undefined\r\n          const keyId = token ? `${exchange}:${token}` : undefined\r\n          const meta = keyId ? tokenMetaRef.current.get(keyId) : undefined\r\n          const symbolKey = meta?.symbol || quote.symbol || (token ? `Token_${token}` : undefined)\r\n          if (!symbolKey) return\r\n\r\n          console.log(`[MarketContext] ðŸ“Š Full quote for key=\"${symbolKey}\" token=${token}: LTP=${quote.ltp}, low=${quote.low}, high=${quote.high}`)\r\n\r\n          copy[symbolKey] = {\r\n            ...(copy[symbolKey] || {}),\r\n            ltp: quote.ltp ?? copy[symbolKey]?.ltp,\r\n            token: token ? Number(token) : copy[symbolKey]?.token,\r\n            exchange,\r\n            timestamp: quote.timestamp || new Date().toISOString(),\r\n            low: quote.low ?? copy[symbolKey]?.low,\r\n            high: quote.high ?? copy[symbolKey]?.high,\r\n            open: quote.open ?? copy[symbolKey]?.open,\r\n            close: quote.close ?? copy[symbolKey]?.close,\r\n            atp: quote.atp ?? copy[symbolKey]?.atp,\r\n            volume: quote.volume ?? copy[symbolKey]?.volume,\r\n            oi: quote.oi ?? copy[symbolKey]?.oi,\r\n            percentChange: quote.percentChange ?? copy[symbolKey]?.percentChange,\r\n            netChange: quote.netChange ?? copy[symbolKey]?.netChange,\r\n            depth: quote.depth ?? copy[symbolKey]?.depth,\r\n            lot_size: copy[symbolKey]?.lot_size,\r\n          }\r\n        })\r\n        console.log('[MarketContext] ðŸ“Š After full quote sync, total keys:', Object.keys(copy).length)\r\n        return copy\r\n      })\r\n    } catch (error) {\r\n      console.error('Market: unable to sync full quotes', error)\r\n    }\r\n  }, [])\r\n\r\n  // Poll for quotes at regular intervals to ensure real-time updates\r\n  const startPolling = useCallback(() => {\r\n    // Avoid starting multiple polling loops\r\n    if (isPollingRef.current) return\r\n    isPollingRef.current = true\r\n    \r\n    // Clear any existing polling\r\n    if (pollingIntervalRef.current) {\r\n      clearInterval(pollingIntervalRef.current)\r\n    }\r\n    \r\n    // Poll every 2 seconds for live data (reduced frequency to avoid overload)\r\n    pollingIntervalRef.current = setInterval(() => {\r\n      if (pendingTokensRef.current.size === 0) return\r\n      \r\n      const tokenList = Array.from(pendingTokensRef.current).map(key => {\r\n        const [exchange, token] = key.split(':')\r\n        return { exchange, token }\r\n      })\r\n      \r\n      // Only sync quotes, don't re-emit subscriptions every interval\r\n      syncFullQuotes(tokenList)\r\n    }, 2000) // Poll every 2 seconds\r\n    \r\n    console.log('[MarketContext] ðŸ”„ Started polling for real-time updates')\r\n  }, [syncFullQuotes])\r\n\r\n  const stopPolling = useCallback(() => {\r\n    isPollingRef.current = false\r\n    if (pollingIntervalRef.current) {\r\n      clearInterval(pollingIntervalRef.current)\r\n      pollingIntervalRef.current = null\r\n      console.log('[MarketContext] â¹ï¸ Stopped polling')\r\n    }\r\n  }, [])\r\n\r\n  const subscribeTokens = useCallback((tokens: TokenInput[]) => {\r\n    try {\r\n      if (!Array.isArray(tokens) || tokens.length === 0) return\r\n\r\n      console.log('[MarketContext] ðŸ“ subscribeTokens called with:', tokens)\r\n\r\n      const formatted = tokens\r\n        .map(token => {\r\n          if (token == null) return null\r\n          if (typeof token === 'object' && 'token' in token) {\r\n            return {\r\n              token: String(token.token),\r\n              exchange: (token.exchange || 'NSE').toUpperCase(),\r\n              symbol: token.symbol,\r\n            }\r\n          }\r\n          return { token: String(token), exchange: 'NSE' }\r\n        })\r\n        .filter(Boolean) as Array<{ token: string; exchange: string; symbol?: string }>\r\n\r\n      if (formatted.length === 0) return\r\n\r\n      console.log('[MarketContext] ðŸ“ Formatted tokens for subscription:', formatted)\r\n\r\n      formatted.forEach(({ token, exchange, symbol }) => {\r\n        const key = `${exchange}:${token}`\r\n        pendingTokensRef.current.add(key)\r\n        tokenMetaRef.current.set(key, { exchange, symbol })\r\n        console.log(`[MarketContext] Added to pending: ${key} -> ${symbol}`)\r\n      })\r\n\r\n      emitPendingSubscriptions()\r\n      syncFullQuotes(formatted.map(({ exchange, token }) => ({ exchange, token })))\r\n      \r\n      // Start polling for continuous updates (only starts once)\r\n      startPolling()\r\n    } catch (error) {\r\n      console.error('Market: failed to subscribe tokens', error)\r\n    }\r\n  }, []) // Empty deps - use refs for any mutable state\r\n\r\n  useEffect(() => {\r\n    // Connect to backend Socket.IO server\r\n    try {\r\n      const socket = io(SOCKET_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        autoConnect: true,\r\n        reconnectionAttempts: Infinity,\r\n        reconnectionDelay: 2000\r\n      })\r\n      socketRef.current = socket\r\n\r\n      socket.on('connect', () => {\r\n        setConnected(true)\r\n        console.log('Market: connected to position WebSocket server')\r\n        emitPendingSubscriptions()\r\n      })\r\n\r\n      socket.on('disconnect', (reason: any) => {\r\n        setConnected(false)\r\n        console.log('Market: disconnected from position WebSocket server', reason)\r\n      })\r\n\r\n      socket.on('positionUpdate', (payload: any) => {\r\n        try {\r\n          const positions = payload?.positions || []\r\n          if (positions.length === 0) return\r\n          \r\n          // Debug: show incoming positions for troubleshooting\r\n          console.log('[MarketContext] ðŸ“¡ positionUpdate received:', {\r\n            positionsCount: positions.length,\r\n            sample: positions.slice(0, 2),\r\n          })\r\n          \r\n          // positions are expected to be parsed market ticks forwarded from backend\r\n          // Example item: { symbol: 'NIFTY 50', token: 26000, ltp: 21123.45, timestamp: '...' }\r\n          setStore(prev => {\r\n            let hasChanges = false\r\n            const copy = { ...prev }\r\n            \r\n            for (const p of positions) {\r\n              const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString()\r\n              const existing = copy[key]\r\n              const newLtp = p.ltp != null ? Number(p.ltp) : existing?.ltp\r\n              \r\n              // Only update if there's actually new data\r\n              if (newLtp !== existing?.ltp || !existing) {\r\n                hasChanges = true\r\n                copy[key] = {\r\n                  ...(existing || {}),\r\n                  ltp: newLtp,\r\n                  token: p.token != null ? Number(p.token) : existing?.token,\r\n                  timestamp: p.timestamp || new Date().toISOString(),\r\n                  low: p.low ?? existing?.low,\r\n                  high: p.high ?? existing?.high,\r\n                  open: p.open ?? existing?.open,\r\n                  close: p.close ?? existing?.close,\r\n                  oi: p.oi ?? existing?.oi,\r\n                  percentChange: p.percentChange ?? p.changePercent ?? existing?.percentChange,\r\n                  netChange: p.netChange ?? p.change ?? existing?.netChange,\r\n                  depth: p.depth ?? existing?.depth,\r\n                  volume: p.volume ?? existing?.volume,\r\n                  lot_size: p.lot_size || existing?.lot_size\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Only return new object if there are actual changes\r\n            return hasChanges ? copy : prev\r\n          })\r\n        } catch (e) {\r\n          console.error('Market: failed to handle positionUpdate', e)\r\n        }\r\n      })\r\n\r\n      socket.on('initialPositions', (payload: any) => {\r\n        try {\r\n          const positions = payload?.positions || []\r\n          const map: Record<string, any> = {}\r\n          for (const p of positions) {\r\n            const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString()\r\n            map[key] = {\r\n              ltp: p.ltp != null ? Number(p.ltp) : undefined,\r\n              token: p.token != null ? Number(p.token) : undefined,\r\n              timestamp: p.timestamp || new Date().toISOString(),\r\n              low: p.low,\r\n              high: p.high,\r\n              open: p.open,\r\n              close: p.close,\r\n              oi: p.oi,\r\n              percentChange: p.percentChange ?? p.changePercent,\r\n              netChange: p.netChange ?? p.change,\r\n              depth: p.depth,\r\n              volume: p.volume,\r\n            }\r\n          }\r\n          setStore(prev => ({ ...prev, ...map }))\r\n          // Debug: load initial map into window variable for inspection\r\n          try { (window as any)._marketSymbolsDebug = map } catch (e) {}\r\n        } catch (e) {\r\n          console.error('Market: failed to handle initialPositions', e)\r\n        }\r\n      })\r\n\r\n      socket.on('connect_error', (err: any) => {\r\n        console.error('Market: socket connect_error', err)\r\n        setConnected(false)\r\n      })\r\n\r\n      return () => {\r\n        try {\r\n          socket.off('positionUpdate')\r\n          socket.off('initialPositions')\r\n          socket.disconnect()\r\n          // Stop polling on cleanup\r\n          if (pollingIntervalRef.current) {\r\n            clearInterval(pollingIntervalRef.current)\r\n            pollingIntervalRef.current = null\r\n          }\r\n        } catch (e) {}\r\n      }\r\n    } catch (e) {\r\n      console.error('Market: failed to initialize socket', e)\r\n    }\r\n  }, [])\r\n\r\n  // Register defaults once after mount\r\n  useEffect(() => {\r\n    if (!defaultsRegisteredRef.current && DEFAULT_TOKENS.length > 0) {\r\n      defaultsRegisteredRef.current = true\r\n      subscribeTokens(DEFAULT_TOKENS)\r\n    }\r\n  }, []) // Run only once on mount\r\n  \r\n  // Cleanup polling on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingIntervalRef.current) {\r\n        clearInterval(pollingIntervalRef.current)\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  // Use a stable reference for subscribeTokens\r\n  const subscribeTokensRef = useRef(subscribeTokens)\r\n  subscribeTokensRef.current = subscribeTokens\r\n\r\n  const stableSubscribeTokens = useCallback((tokens: TokenInput[]) => {\r\n    subscribeTokensRef.current(tokens)\r\n  }, [])\r\n\r\n  const state = useMemo(\r\n    () => ({ symbols: store, connected, subscribeTokens: stableSubscribeTokens }),\r\n    [store, connected, stableSubscribeTokens],\r\n  )\r\n\r\n  return <MarketContext.Provider value={state}>{children}</MarketContext.Provider>\r\n}\r\n\r\nexport function useMarket() {\r\n  const ctx = useContext(MarketContext)\r\n  if (!ctx) throw new Error('useMarket must be used within MarketProvider')\r\n  return ctx\r\n}\r\n"],"names":[],"mappings":"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"}}]
}