module.exports = [
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[project]/components/market/market-context.tsx [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MarketProvider",
    ()=>MarketProvider,
    "useMarket",
    ()=>useMarket
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
"use client";
;
;
;
const MarketContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(null);
const SOCKET_URL = ("TURBOPACK compile-time value", "http://localhost:5000") || 'http://localhost:5000';
const API_BASE = ("TURBOPACK compile-time value", "http://localhost:5000") || 'http://localhost:5000';
// Default tokens will be fetched dynamically from API when needed
// These are just placeholder keys - actual tokens come from database when symbol is selected
const DEFAULT_TOKENS = [];
function MarketProvider({ children }) {
    const [store, setStore] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])({});
    const [connected, setConnected] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(false);
    const socketRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const pendingTokensRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(new Set());
    const tokenMetaRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(new Map());
    const defaultsRegisteredRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(false);
    const pollingIntervalRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const emitPendingSubscriptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        if (!socketRef.current || !socketRef.current.connected || pendingTokensRef.current.size === 0) return;
        const payload = Array.from(pendingTokensRef.current).map((key)=>{
            const [exchange, token] = key.split(':');
            const meta = tokenMetaRef.current.get(key);
            const symbol = meta?.symbol;
            return {
                exchange,
                token,
                symbol,
                symbolName: symbol
            };
        });
        try {
            socketRef.current.emit('subscribePositions', {
                brokerId: 'market',
                tokens: payload,
                updateInterval: 5
            });
            console.log('Market: emitted subscribePositions for tokens', payload);
        } catch (e) {
            console.error('Market: failed to emit subscribePositions', e);
        }
    }, []);
    const syncFullQuotes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(async (tokenList)=>{
        if (!tokenList || tokenList.length === 0) return;
        // Deduplicate tokens per exchange
        const dedupMap = new Map();
        tokenList.forEach((item)=>{
            if (!item?.token) return;
            const exchange = (item.exchange || 'NSE').toUpperCase();
            const key = `${exchange}:${item.token}`;
            dedupMap.set(key, {
                exchange,
                token: String(item.token)
            });
        });
        if (dedupMap.size === 0) return;
        try {
            const response = await fetch(`${API_BASE}/api/quotes/full`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    tokens: Array.from(dedupMap.values())
                })
            });
            const json = await response.json();
            if (!json?.success || !Array.isArray(json.data)) return;
            setStore((prev)=>{
                const copy = {
                    ...prev
                };
                json.data.forEach((quote)=>{
                    if (!quote) return;
                    const exchange = (quote.exchange || 'NSE').toUpperCase();
                    const token = quote.token ? String(quote.token) : undefined;
                    const keyId = token ? `${exchange}:${token}` : undefined;
                    const meta = keyId ? tokenMetaRef.current.get(keyId) : undefined;
                    const symbolKey = meta?.symbol || quote.symbol || (token ? `Token_${token}` : undefined);
                    if (!symbolKey) return;
                    console.log(`[MarketContext] ðŸ“Š Full quote for key="${symbolKey}" token=${token}: LTP=${quote.ltp}, low=${quote.low}, high=${quote.high}`);
                    copy[symbolKey] = {
                        ...copy[symbolKey] || {},
                        ltp: quote.ltp ?? copy[symbolKey]?.ltp,
                        token: token ? Number(token) : copy[symbolKey]?.token,
                        exchange,
                        timestamp: quote.timestamp || new Date().toISOString(),
                        low: quote.low ?? copy[symbolKey]?.low,
                        high: quote.high ?? copy[symbolKey]?.high,
                        open: quote.open ?? copy[symbolKey]?.open,
                        close: quote.close ?? copy[symbolKey]?.close,
                        atp: quote.atp ?? copy[symbolKey]?.atp,
                        volume: quote.volume ?? copy[symbolKey]?.volume,
                        oi: quote.oi ?? copy[symbolKey]?.oi,
                        percentChange: quote.percentChange ?? copy[symbolKey]?.percentChange,
                        netChange: quote.netChange ?? copy[symbolKey]?.netChange,
                        depth: quote.depth ?? copy[symbolKey]?.depth,
                        lot_size: copy[symbolKey]?.lot_size
                    };
                });
                console.log('[MarketContext] ðŸ“Š After full quote sync, total keys:', Object.keys(copy).length);
                return copy;
            });
        } catch (error) {
            console.error('Market: unable to sync full quotes', error);
        }
    }, []);
    // Poll for quotes at regular intervals to ensure real-time updates
    const startPolling = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        // Clear any existing polling
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
        }
        // Poll every 1 second for live data
        pollingIntervalRef.current = setInterval(()=>{
            if (pendingTokensRef.current.size === 0) return;
            const tokenList = Array.from(pendingTokensRef.current).map((key)=>{
                const [exchange, token] = key.split(':');
                return {
                    exchange,
                    token
                };
            });
            // Re-emit subscription to keep it alive and fetch latest quotes
            emitPendingSubscriptions();
            syncFullQuotes(tokenList);
        }, 1000); // Poll every 1 second
        console.log('[MarketContext] ðŸ”„ Started polling for real-time updates');
    }, [
        emitPendingSubscriptions,
        syncFullQuotes
    ]);
    const stopPolling = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
            console.log('[MarketContext] â¹ï¸ Stopped polling');
        }
    }, []);
    const subscribeTokens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])((tokens)=>{
        try {
            if (!Array.isArray(tokens) || tokens.length === 0) return;
            console.log('[MarketContext] ðŸ“ subscribeTokens called with:', tokens);
            const formatted = tokens.map((token)=>{
                if (token == null) return null;
                if (typeof token === 'object' && 'token' in token) {
                    return {
                        token: String(token.token),
                        exchange: (token.exchange || 'NSE').toUpperCase(),
                        symbol: token.symbol
                    };
                }
                return {
                    token: String(token),
                    exchange: 'NSE'
                };
            }).filter(Boolean);
            if (formatted.length === 0) return;
            console.log('[MarketContext] ðŸ“ Formatted tokens for subscription:', formatted);
            formatted.forEach(({ token, exchange, symbol })=>{
                const key = `${exchange}:${token}`;
                pendingTokensRef.current.add(key);
                tokenMetaRef.current.set(key, {
                    exchange,
                    symbol
                });
                console.log(`[MarketContext] Added to pending: ${key} -> ${symbol}`);
            });
            emitPendingSubscriptions();
            syncFullQuotes(formatted.map(({ exchange, token })=>({
                    exchange,
                    token
                })));
            // Start polling for continuous updates
            startPolling();
        } catch (error) {
            console.error('Market: failed to subscribe tokens', error);
        }
    }, [
        emitPendingSubscriptions,
        syncFullQuotes,
        startPolling
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        // Connect to backend Socket.IO server
        try {
            const socket = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["io"])(SOCKET_URL, {
                transports: [
                    'websocket',
                    'polling'
                ],
                autoConnect: true,
                reconnectionAttempts: Infinity,
                reconnectionDelay: 2000
            });
            socketRef.current = socket;
            socket.on('connect', ()=>{
                setConnected(true);
                console.log('Market: connected to position WebSocket server');
                emitPendingSubscriptions();
            });
            socket.on('disconnect', (reason)=>{
                setConnected(false);
                console.log('Market: disconnected from position WebSocket server', reason);
            });
            socket.on('positionUpdate', (payload)=>{
                try {
                    const positions = payload?.positions || [];
                    // Debug: show incoming positions for troubleshooting
                    console.log('[MarketContext] ðŸ“¡ positionUpdate received:', {
                        positionsCount: positions.length,
                        positions: positions.slice(0, 3),
                        fullPayload: payload
                    });
                    // positions are expected to be parsed market ticks forwarded from backend
                    // Example item: { symbol: 'NIFTY 50', token: 26000, ltp: 21123.45, timestamp: '...' }
                    setStore((prev)=>{
                        const copy = {
                            ...prev
                        };
                        for (const p of positions){
                            const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString();
                            console.log(`[MarketContext] ðŸ“ Updating key="${key}" token=${p.token} with LTP: ${p.ltp}, low: ${p.low}, high: ${p.high}`);
                            copy[key] = {
                                ...copy[key] || {},
                                ltp: p.ltp != null ? Number(p.ltp) : copy[key]?.ltp,
                                token: p.token != null ? Number(p.token) : copy[key]?.token,
                                timestamp: p.timestamp || new Date().toISOString(),
                                low: p.low || copy[key]?.low,
                                high: p.high || copy[key]?.high,
                                open: p.open ?? copy[key]?.open,
                                close: p.close ?? copy[key]?.close,
                                oi: p.oi ?? copy[key]?.oi,
                                percentChange: p.percentChange ?? p.changePercent ?? copy[key]?.percentChange,
                                netChange: p.netChange ?? p.change ?? copy[key]?.netChange,
                                depth: p.depth ?? copy[key]?.depth,
                                volume: p.volume ?? copy[key]?.volume,
                                lot_size: p.lot_size || copy[key]?.lot_size
                            };
                        }
                        console.log('[MarketContext] ðŸ“Š Store updated, total symbols:', Object.keys(copy).length);
                        return copy;
                    });
                    // Debug: expose current market symbols map for troubleshooting in browser console
                    try {
                        window._marketSymbolsDebug = window._marketSymbolsDebug || {};
                        Object.assign(window._marketSymbolsDebug, positions.reduce((acc, p)=>{
                            const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString();
                            acc[key] = p;
                            return acc;
                        }, {}));
                    } catch (e) {}
                } catch (e) {
                    console.error('Market: failed to handle positionUpdate', e);
                }
            });
            socket.on('initialPositions', (payload)=>{
                try {
                    const positions = payload?.positions || [];
                    const map = {};
                    for (const p of positions){
                        const key = (p.symbol || p.symbolName || p.name || `Token_${p.token || ''}`).toString();
                        map[key] = {
                            ltp: p.ltp != null ? Number(p.ltp) : undefined,
                            token: p.token != null ? Number(p.token) : undefined,
                            timestamp: p.timestamp || new Date().toISOString(),
                            low: p.low,
                            high: p.high,
                            open: p.open,
                            close: p.close,
                            oi: p.oi,
                            percentChange: p.percentChange ?? p.changePercent,
                            netChange: p.netChange ?? p.change,
                            depth: p.depth,
                            volume: p.volume
                        };
                    }
                    setStore((prev)=>({
                            ...prev,
                            ...map
                        }));
                    // Debug: load initial map into window variable for inspection
                    try {
                        window._marketSymbolsDebug = map;
                    } catch (e) {}
                } catch (e) {
                    console.error('Market: failed to handle initialPositions', e);
                }
            });
            socket.on('connect_error', (err)=>{
                console.error('Market: socket connect_error', err);
                setConnected(false);
            });
            return ()=>{
                try {
                    socket.off('positionUpdate');
                    socket.off('initialPositions');
                    socket.disconnect();
                    // Stop polling on cleanup
                    if (pollingIntervalRef.current) {
                        clearInterval(pollingIntervalRef.current);
                        pollingIntervalRef.current = null;
                    }
                } catch (e) {}
            };
        } catch (e) {
            console.error('Market: failed to initialize socket', e);
        }
    }, []);
    // Register defaults once after mount
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (!defaultsRegisteredRef.current) {
            defaultsRegisteredRef.current = true;
            subscribeTokens(DEFAULT_TOKENS);
        }
    }, [
        subscribeTokens
    ]);
    // Cleanup polling on unmount
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        return ()=>{
            if (pollingIntervalRef.current) {
                clearInterval(pollingIntervalRef.current);
            }
        };
    }, []);
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            symbols: store,
            connected,
            subscribeTokens
        }), [
        store,
        connected,
        subscribeTokens
    ]);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(MarketContext.Provider, {
        value: state,
        children: children
    }, void 0, false, {
        fileName: "[project]/components/market/market-context.tsx",
        lineNumber: 346,
        columnNumber: 10
    }, this);
}
function useMarket() {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(MarketContext);
    if (!ctx) throw new Error('useMarket must be used within MarketProvider');
    return ctx;
}
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/dynamic-access-async-storage.external.js [external] (next/dist/server/app-render/dynamic-access-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/dynamic-access-async-storage.external.js", () => require("next/dist/server/app-render/dynamic-access-async-storage.external.js"));

module.exports = mod;
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__da28ddb4._.js.map