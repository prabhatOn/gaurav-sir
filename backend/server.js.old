const express = require('express');
const cors = require('cors');
const http = require('http');
const { Server } = require('socket.io');
const angelOneService = require('./services/angelOneService');
const { testConnection } = require('./config/database');
require('dotenv').config({ path: '../.env.local' });

// Initialize Express app
const app = express();
const server = http.createServer(app);

// Socket.IO configuration with proper CORS
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization']
  },
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000
});

// ============================================================================
// MIDDLEWARE
// ============================================================================

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Body parsers
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Request logging middleware
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${req.method} ${req.url}`);
  if (Object.keys(req.body).length > 0 && req.method !== 'GET') {
    console.log(`[${timestamp}] Body:`, JSON.stringify(req.body, null, 2));
  }
  next();
});

// Response time tracking
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url} - ${res.statusCode} (${duration}ms)`);
  });
  next();
});

// ============================================================================
// ROUTES
// ============================================================================

const apiRoutes = require('./routes/api');
const symbolsRoutes = require('./routes/symbols');
const ordersRoutes = require('./routes/orders');
const positionsRoutes = require('./routes/positions');
const tradingRoutes = require('./routes/trading');

// Mount routes
app.use('/api', apiRoutes);
app.use('/api/symbols', symbolsRoutes);
app.use('/api/orders', ordersRoutes);
app.use('/api/positions', positionsRoutes);
app.use('/api/trading', tradingRoutes);

// SmartAPI integration enabled
console.log(`ðŸš€ Server running with SmartAPI integration`);

// Create HTTP server for API endpoints
const server = http.createServer(async (req, res) => {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  // Simple debug endpoint to inspect server state
  if (req.url === '/debug') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      status: 'Trading server running',
      timestamp: new Date().toISOString(),
      mode: 'PRODUCTION'
    }));
    return;
  }

  // GET /api/symbols - Get available trading symbols
  if (req.url === '/api/symbols' && req.method === 'GET') {
    try {
      const symbols = await query('SELECT * FROM symbols ORDER BY name');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: symbols }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/symbols/search - Search symbols with query and limit
  if (req.url.startsWith('/api/symbols/search') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const q = url.searchParams.get('q') || '';
    const limit = parseInt(url.searchParams.get('limit') || '50');
    try {
      const symbols = await query(`
        SELECT id, symbol, name, exchange, segment, instrument_type, lot_size
        FROM symbols 
        WHERE symbol LIKE ? OR name LIKE ?
        ORDER BY name
        LIMIT ?
      `, [`%${q}%`, `%${q}%`, limit]);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: symbols }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/symbols/:symbol - Get single symbol details
  if (req.url.match(/^\/api\/symbols\/[^\/]+$/) && req.method === 'GET' && !req.url.includes('/expiries')) {
    const symbol = req.url.split('/')[3];
    try {
      const symbols = await query('SELECT * FROM symbols WHERE symbol = ? LIMIT 1', [symbol]);
      if (symbols.length === 0) {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Symbol not found' }));
        return;
      }
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: symbols[0] }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/orders - Get user orders (with broker filtering)
  if (req.url.startsWith('/api/orders') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');
    const status = url.searchParams.get('status');

    try {
      let queryStr = `
        SELECT o.*, s.name as symbol_name, s.exchange, b.name as broker_name, b.broker_type
        FROM orders o
        JOIN symbols s ON o.symbol_id = s.id
        JOIN brokers b ON o.broker_id = b.id
      `;
      const params = [];

      if (brokerId || status) {
        const conditions = [];
        if (brokerId) {
          conditions.push('o.broker_id = ?');
          params.push(brokerId);
        }
        if (status) {
          conditions.push('o.order_status = ?');
          params.push(status);
        }
        queryStr += ' WHERE ' + conditions.join(' AND ');
      }

      queryStr += ' ORDER BY o.order_timestamp DESC';

      const orders = await query(queryStr, params);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: orders }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/orders - Place new order
  if (req.url === '/api/orders' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const orderData = JSON.parse(body);

        // Basic validation: symbol and transaction_type and quantity required
        if (!orderData || !orderData.symbol) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required field: symbol' }));
          return;
        }
        if (!orderData.transaction_type && !orderData.transactionType) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required field: transaction_type' }));
          return;
        }
        if (orderData.quantity == null) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required field: quantity' }));
          return;
        }

        // Find symbol by name
        const symbols = await query('SELECT * FROM symbols WHERE symbol = ?', [orderData.symbol]);
        if (symbols.length === 0) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Symbol not found' }));
          return;
        }
        const symbol = symbols[0];

        // Calculate price based on order type and sanitize undefined -> null
        let price = orderData.price === undefined ? null : orderData.price
        let trigger_price = orderData.trigger_price === undefined ? null : orderData.trigger_price
        const incomingOrderType = orderData.order_type ?? orderData.orderType ?? 'Market'
        if (incomingOrderType === 'Market') {
          price = null
        } else if (incomingOrderType === 'Limit' && (price == null)) {
          price = null
        }

        // normalize other fields for DB insertion
        const transaction_type = orderData.transaction_type ?? orderData.transactionType ?? 'BUY'
        const quantity = Number(orderData.quantity) || 0
        let product_type = orderData.product_type ?? orderData.productType ?? 'MIS'
        if (product_type === 'Margin') product_type = 'CNC'
        else if (product_type === 'Cash') product_type = 'NRML'

        // Insert order into database
        const result = await query(`INSERT INTO orders
          (symbol_id, order_type, transaction_type, quantity, price, trigger_price, product_type, order_status, filled_quantity, remaining_quantity)
          VALUES (?, ?, ?, ?, ?, ?, ?, 'pending', 0, ?)`,
          [symbol.id, incomingOrderType, transaction_type, quantity,
           price, trigger_price, product_type, quantity]);

        // Execute market orders immediately
        if (incomingOrderType === 'Market') {
          await query('UPDATE orders SET order_status = ?, filled_quantity = ?, remaining_quantity = ? WHERE id = ?',
            ['executed', quantity, 0, result.insertId]);
          
          const positionQuantity = transaction_type === 'BUY' ? quantity : -quantity;
          await query('INSERT INTO positions (symbol_id, quantity, average_price) VALUES (?, ?, ?)',
            [symbol.id, positionQuantity, price]);
        }

        const newOrder = {
          id: result.insertId,
          symbol_id: symbol.id,
          order_type: incomingOrderType,
          transaction_type,
          quantity,
          price,
          trigger_price,
          product_type,
          order_status: incomingOrderType === 'Market' ? 'executed' : 'pending',
          filled_quantity: incomingOrderType === 'Market' ? quantity : 0,
          remaining_quantity: incomingOrderType === 'Market' ? 0 : quantity,
          order_timestamp: new Date()
        };

        res.writeHead(201, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: newOrder }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // PUT /api/orders/:id/cancel - Cancel order
  if (req.url.match(/^\/api\/orders\/\d+\/cancel$/) && req.method === 'PUT') {
    const orderId = req.url.split('/')[3];
    try {
      await query('UPDATE orders SET order_status = ? WHERE id = ?', ['cancelled', orderId]);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, message: 'Order cancelled' }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/positions - Get user positions (with broker filtering)
  if (req.url.startsWith('/api/positions') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      let queryStr = `
        SELECT p.*, s.name as symbol_name, s.exchange, b.name as broker_name, b.broker_type
        FROM positions p
        JOIN symbols s ON p.symbol_id = s.id
        JOIN brokers b ON p.broker_id = b.id
      `;
      const params = [];

      if (brokerId) {
        queryStr += ' WHERE p.broker_id = ?';
        params.push(brokerId);
      }

      queryStr += ' ORDER BY p.created_at DESC';

      const positions = await query(queryStr, params);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: positions }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/holdings - Get user holdings (with broker filtering)
  if (req.url.startsWith('/api/holdings') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      let queryStr = `
        SELECT h.*, s.name as symbol_name, s.exchange, b.name as broker_name, b.broker_type
        FROM holdings h
        JOIN symbols s ON h.symbol_id = s.id
        JOIN brokers b ON h.broker_id = b.id
      `;
      const params = [];

      if (brokerId) {
        queryStr += ' WHERE h.broker_id = ?';
        params.push(brokerId);
      }

      queryStr += ' ORDER BY h.created_at DESC';

      const holdings = await query(queryStr, params);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: holdings }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/trades - Get trade history (with broker filtering)
  if (req.url.startsWith('/api/trades') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      let queryStr = `
        SELECT t.*, s.name as symbol_name, s.exchange, b.name as broker_name, b.broker_type
        FROM trades t
        JOIN symbols s ON t.symbol_id = s.id
        JOIN brokers b ON t.broker_id = b.id
      `;
      const params = [];

      if (brokerId) {
        queryStr += ' WHERE t.broker_id = ?';
        params.push(brokerId);
      }

      queryStr += ' ORDER BY t.trade_timestamp DESC';

      const trades = await query(queryStr, params);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: trades }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/baskets - Create basket order (with multi-broker support)
  if (req.url === '/api/baskets' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const basketData = JSON.parse(body);

        // Check if this is a multi-broker basket order
        if (basketData.distribute && basketData.distribute === true) {
          // Use the new multi-broker distribution logic
          const distributionResult = await brokerManager.distributeBasketOrder(basketData, {
            distributionAlgorithm: basketData.algorithm || 'round-robin',
            maxBrokers: basketData.maxBrokers || 3,
            retryAttempts: basketData.retryAttempts || 2,
            fallbackEnabled: basketData.fallbackEnabled !== false
          });

          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            status: true,
            data: distributionResult,
            message: 'Basket order distributed across multiple brokers'
          }));
          return;
        }

        // Original single-broker basket creation logic
        const result = await query('INSERT INTO basket_orders (basket_name, broker_id, status, total_brokers) VALUES (?, ?, ?, ?)',
          [basketData.name || 'Unnamed Basket', basketData.brokerId || 1, 'draft', basketData.totalBrokers || 1]);
        const basketId = result.insertId;

        // Insert basket items
        for (const item of basketData.items || basketData.positions || []) {
          // Find symbol by name
          const symbols = await query('SELECT id FROM symbols WHERE symbol = ? OR name = ?', [item.symbol, item.symbol]);
          if (symbols.length === 0) continue; // Skip if symbol not found
          const symbolId = symbols[0].id;

          await query('INSERT INTO basket_order_items (basket_order_id, broker_id, symbol_id, order_type, transaction_type, quantity, price, execution_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
            [basketId, item.brokerId || basketData.brokerId || 1, symbolId, item.type || item.order_type || 'MKT', item.transaction_type || (item.qty > 0 ? 'BUY' : 'SELL'), Math.abs(item.qty || item.quantity), item.price || null, 'pending']);
        }

        res.writeHead(201, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          status: true,
          data: {
            id: basketId,
            name: basketData.name,
            brokerId: basketData.brokerId,
            positions: basketData.items || basketData.positions
          }
        }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // GET /api/baskets - Get saved baskets (with broker filtering)
  if (req.url.startsWith('/api/baskets') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      let queryStr = `
        SELECT bo.*, GROUP_CONCAT(
          JSON_OBJECT(
            'symbol', s.symbol,
            'name', s.name,
            'expiry', DATE_FORMAT(s.expiry_date, '%d-%b-%Y'),
            'strike', s.strike_price,
            'cepe', s.option_type,
            'qty', CASE WHEN boi.transaction_type = 'SELL' THEN -boi.quantity ELSE boi.quantity END,
            'type', boi.order_type,
            'price', boi.price,
            'transaction_type', boi.transaction_type,
            'broker_id', boi.broker_id
          )
        ) as positions_json
        FROM basket_orders bo
        LEFT JOIN basket_order_items boi ON bo.id = boi.basket_order_id
        LEFT JOIN symbols s ON boi.symbol_id = s.id
      `;
      const params = [];

      if (brokerId) {
        queryStr += ' WHERE bo.broker_id = ?';
        params.push(brokerId);
      }

      queryStr += ' GROUP BY bo.id ORDER BY bo.created_at DESC';

      const baskets = await query(queryStr, params);

      const formattedBaskets = baskets.map(b => ({
        id: b.id,
        name: b.basket_name,
        brokerId: b.broker_id,
        status: b.status,
        totalBrokers: b.total_brokers,
        positions: b.positions_json ? JSON.parse(`[${b.positions_json}]`) : [],
        createdAt: b.created_at
      }));

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: formattedBaskets }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // PUT /api/baskets/:id - Update basket
  if (req.url.match(/^\/api\/baskets\/\d+$/) && req.method === 'PUT') {
    const basketId = req.url.split('/')[3];
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const basketData = JSON.parse(body);

        // Update basket name
        await query('UPDATE basket_orders SET basket_name = ? WHERE id = ?', [basketData.name, basketId]);

        // Delete existing items
        await query('DELETE FROM basket_order_items WHERE basket_order_id = ?', [basketId]);

        // Insert new items
        for (const item of basketData.positions || []) {
          const symbols = await query('SELECT id FROM symbols WHERE symbol = ? OR name = ?', [item.symbol, item.symbol]);
          if (symbols.length === 0) continue;
          const symbolId = symbols[0].id;

          await query('INSERT INTO basket_order_items (basket_order_id, symbol_id, order_type, transaction_type, quantity, price) VALUES (?, ?, ?, ?, ?, ?)',
            [basketId, symbolId, item.type, item.transaction_type || (item.qty > 0 ? 'BUY' : 'SELL'), Math.abs(item.qty), item.price]);
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, message: 'Basket updated' }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // DELETE /api/baskets/:id - Delete basket
  if (req.url.match(/^\/api\/baskets\/\d+$/) && req.method === 'DELETE') {
    const basketId = req.url.split('/')[3];
    try {
      await query('DELETE FROM basket_order_items WHERE basket_order_id = ?', [basketId]);
      await query('DELETE FROM basket_orders WHERE id = ?', [basketId]);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, message: 'Basket deleted' }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/symbols/:symbol/expiries - Get available expiries for a symbol
  if (req.url.match(/^\/api\/symbols\/[^\/]+\/expiries$/) && req.method === 'GET') {
    const symbol = req.url.split('/')[3];
    try {
      const expiries = await query(`
        SELECT DISTINCT DATE_FORMAT(expiry_date, '%d-%b-%Y') as expiry
        FROM symbols 
        WHERE symbol = ? AND expiry_date IS NOT NULL 
        ORDER BY expiry_date
      `, [symbol]);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: expiries.map(e => e.expiry) }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/symbols/:symbol/expiries/:expiry/strikes - Get available strikes for symbol and expiry
  if (req.url.match(/^\/api\/symbols\/[^\/]+\/expiries\/[^\/]+\/strikes$/) && req.method === 'GET') {
    const parts = req.url.split('/');
    const symbol = parts[3];
    const expiryStr = parts[5];
    try {
      // Parse expiry '25-Nov-2025' to MySQL date format
      const months = { 'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06',
                      'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12' };
      const parts = expiryStr.split('-');
      const day = parts[0].padStart(2, '0');
      const month = months[parts[1]];
      const year = parts[2];
      const formattedExpiry = `${year}-${month}-${day}`;
      
      const strikes = await query(`
        SELECT DISTINCT strike_price as strike
        FROM symbols 
        WHERE symbol = ? AND DATE(expiry_date) = ? AND strike_price IS NOT NULL
        ORDER BY strike_price
      `, [symbol, formattedExpiry]);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: strikes.map(s => s.strike) }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/option-chain/:symbol - Get option chain data from SmartAPI
  if (req.url.match(/^\/api\/option-chain\/[^\/]+$/) && req.method === 'GET') {
    const symbol = req.url.split('/')[3];
    try {
      const optionChain = await getOptionChain(symbol);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: optionChain }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/ltp/:symbol - Get LTP data from SmartAPI
  if (req.url.match(/^\/api\/ltp\/[^\/]+$/) && req.method === 'GET') {
    const symbol = req.url.split('/')[3];
    try {
      const ltp = await getLTP(symbol);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: ltp }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/fetch-instruments - Fetch and save instrument master data
  if (req.url === '/api/fetch-instruments' && req.method === 'POST') {
    fetchAndSaveInstruments().then(() => {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, message: 'Instruments fetched and saved' }));
    }).catch(error => {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    });
    return;
  }

  // GET /api/funds - Get funds/margin info (with broker filtering)
  if (req.url.startsWith('/api/funds') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      if (brokerId) {
        // Get broker-specific funds
        const funds = await query(`
          SELECT bf.*, b.name as broker_name, b.broker_type
          FROM broker_funds bf
          JOIN brokers b ON bf.broker_id = b.id
          WHERE bf.broker_id = ?
        `, [brokerId]);

        if (funds.length > 0) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ status: true, data: funds[0] }));
        } else {
          res.writeHead(404, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Broker funds not found' }));
        }
      } else {
        // Get consolidated funds across all brokers
        const allFunds = await query(`
          SELECT
            SUM(available_margin) as total_available_margin,
            SUM(used_margin) as total_used_margin,
            SUM(total_balance) as total_balance,
            SUM(realized_pnl) as total_realized_pnl,
            SUM(unrealized_pnl) as total_unrealized_pnl
          FROM broker_funds bf
          JOIN brokers b ON bf.broker_id = b.id
          WHERE b.is_active = TRUE
        `);

        const consolidatedFunds = allFunds[0] || {
          total_available_margin: 0,
          total_used_margin: 0,
          total_balance: 0,
          total_realized_pnl: 0,
          total_unrealized_pnl: 0
        };

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: consolidatedFunds }));
      }
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/accounts - Get trading accounts
  if (req.url === '/api/accounts' && req.method === 'GET') {
    try {
      const accounts = [
        { name: 'NSE - Derivatives' },
        { name: 'NSE - Equity' }
      ];
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: accounts }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/realized-pnl - Get realized P&L (with broker filtering)
  if (req.url.startsWith('/api/realized-pnl') && req.method === 'GET') {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const brokerId = url.searchParams.get('brokerId');

    try {
      let queryStr = `
        SELECT t.transaction_type, t.price, t.quantity, t.trade_value, b.name as broker_name
        FROM trades t
        JOIN brokers b ON t.broker_id = b.id
      `;
      const params = [];

      if (brokerId) {
        queryStr += ' WHERE t.broker_id = ?';
        params.push(brokerId);
      }

      queryStr += ' ORDER BY t.trade_timestamp';

      const trades = await query(queryStr, params);

      let realizedPnL = 0;
      // Simple calculation: sum of all trade values (positive for buys, negative for sells)
      // In a real system, this would be more complex with position tracking
      for (const trade of trades) {
        if (trade.transaction_type === 'SELL') {
          realizedPnL += trade.trade_value || (trade.price * trade.quantity);
        } else if (trade.transaction_type === 'BUY') {
          realizedPnL -= trade.trade_value || (trade.price * trade.quantity);
        }
      }

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        status: true,
        data: {
          realized_pnl: realizedPnL,
          broker_id: brokerId,
          trade_count: trades.length
        }
      }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/column-settings/:component - Get column settings for a component
  if (req.url.match(/^\/api\/column-settings\/[^\/]+$/) && req.method === 'GET') {
    const component = req.url.split('/')[3];
    try {
      const settings = await query('SELECT * FROM column_settings WHERE component = ? LIMIT 1', [component]);
      if (settings.length > 0) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: JSON.parse(settings[0].settings) }));
      } else {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: null }));
      }
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/column-settings/:component - Save column settings for a component
  if (req.url.match(/^\/api\/column-settings\/[^\/]+$/) && req.method === 'POST') {
    const component = req.url.split('/')[3];
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const settings = JSON.parse(body);
        
        // Upsert: try to update first, if no rows affected, insert
        const updateResult = await query(
          'UPDATE column_settings SET settings = ?, updated_at = CURRENT_TIMESTAMP WHERE component = ?',
          [JSON.stringify(settings), component]
        );
        
        if (updateResult.affectedRows === 0) {
          await query(
            'INSERT INTO column_settings (component, settings) VALUES (?, ?)',
            [component, JSON.stringify(settings)]
          );
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, message: 'Settings saved' }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // === BROKER MANAGEMENT API ENDPOINTS ===

  // GET /api/brokers - Get all brokers
  if (req.url === '/api/brokers' && req.method === 'GET') {
    try {
      const brokers = await brokerManager.getAllBrokers();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: brokers }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/brokers - Create new broker
  if (req.url === '/api/brokers' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const brokerData = JSON.parse(body);

        // Validate required fields
        if (!brokerData.name || !brokerData.brokerType || !brokerData.apiKey || !brokerData.apiSecret) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required fields: name, brokerType, apiKey, apiSecret' }));
          return;
        }

        const result = await brokerManager.createBroker(brokerData);
        if (result.success) {
          res.writeHead(201, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ status: true, data: result.broker }));
        } else {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: result.error }));
        }
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // PUT /api/brokers/:id - Update broker
  if (req.url.match(/^\/api\/brokers\/\d+$/) && req.method === 'PUT') {
    const brokerId = parseInt(req.url.split('/')[3]);
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const brokerData = JSON.parse(body);

        // Validate required fields
        if (!brokerData.name || !brokerData.brokerType || !brokerData.apiKey || !brokerData.apiSecret) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required fields: name, brokerType, apiKey, apiSecret' }));
          return;
        }

        const result = await brokerManager.updateBroker(brokerId, brokerData);
        if (result.success) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ status: true, message: 'Broker updated successfully' }));
        } else {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: result.error }));
        }
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // DELETE /api/brokers/:id - Delete broker
  if (req.url.match(/^\/api\/brokers\/\d+$/) && req.method === 'DELETE') {
    const brokerId = parseInt(req.url.split('/')[3]);
    try {
      const result = await brokerManager.deleteBroker(brokerId);
      if (result.success) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, message: 'Broker deleted successfully' }));
      } else {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: result.error }));
      }
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // PUT /api/brokers/:id/toggle - Toggle broker active status
  if (req.url.match(/^\/api\/brokers\/\d+\/toggle$/) && req.method === 'PUT') {
    const brokerId = parseInt(req.url.split('/')[3]);
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const { isActive } = JSON.parse(body);
        const result = await brokerManager.toggleBrokerStatus(brokerId, isActive);
        if (result.success) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ status: true, message: `Broker ${isActive ? 'activated' : 'deactivated'} successfully` }));
        } else {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: result.error }));
        }
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // GET /api/brokers/health - Get broker health status
  if (req.url === '/api/brokers/health' && req.method === 'GET') {
    try {
      const health = await brokerManager.getBrokerHealth();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: health }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/brokers/:id/sync - Sync broker data
  if (req.url.match(/^\/api\/brokers\/\d+\/sync$/) && req.method === 'POST') {
    const brokerId = parseInt(req.url.split('/')[3]);
    try {
      const result = await brokerManager.syncBrokerData(brokerId);
      if (result.success) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: result.data, message: 'Broker data synced successfully' }));
      } else {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: result.error }));
      }
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/brokers/:id/orders - Place order on specific broker
  if (req.url.match(/^\/api\/brokers\/\d+\/orders$/) && req.method === 'POST') {
    const brokerId = parseInt(req.url.split('/')[3]);
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const orderData = JSON.parse(body);
        const result = await brokerManager.placeOrder(brokerId, orderData);
        res.writeHead(201, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: result }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // POST /api/brokers/orders/basket - Place basket order across multiple brokers
  if (req.url === '/api/brokers/orders/basket' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const basketData = JSON.parse(body);
        const results = await brokerManager.distributeBasketOrder(basketData, {
          distributionAlgorithm: basketData.algorithm || 'round-robin',
          maxBrokers: basketData.maxBrokers || 3,
          retryAttempts: basketData.retryAttempts || 2,
          fallbackEnabled: basketData.fallbackEnabled !== false
        });
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: true, data: results }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // GET /api/brokers/orders/aggregated - Get aggregated order status from all brokers
  if (req.url === '/api/brokers/orders/aggregated' && req.method === 'GET') {
    try {
      const url = new URL(req.url, `http://${req.headers.host}`);
      const orderIds = url.searchParams.get('orderIds')?.split(',') || null;
      const orders = await brokerManager.getAggregatedOrderStatus(orderIds);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: orders }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/brokers/portfolio/consolidated - Get consolidated portfolio across all brokers
  if (req.url === '/api/brokers/portfolio/consolidated' && req.method === 'GET') {
    try {
      const portfolio = await brokerManager.getConsolidatedPortfolio();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: portfolio }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/brokers/sync/all - Sync all broker data
  if (req.url === '/api/brokers/sync/all' && req.method === 'POST') {
    try {
      const results = await brokerManager.syncAllBrokerData();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: results }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/basket-orders - Create new basket order
  if (req.url === '/api/basket-orders' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const basketData = JSON.parse(body);

        if (!basketData.name || !basketData.items || !Array.isArray(basketData.items)) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Missing required fields: name and items array' }));
          return;
        }

        // Calculate total quantity and value
        const totalQuantity = basketData.items.reduce((sum, item) => sum + (item.quantity || 0), 0);
        const totalValue = basketData.items.reduce((sum, item) => sum + ((item.quantity || 0) * (item.price || 0)), 0);

        // Create basket order
        const basketResult = await query(`INSERT INTO basket_orders
          (basket_name, basket_type, total_quantity, total_value, status, distribution_algorithm, max_brokers)
          VALUES (?, ?, ?, ?, 'pending', ?, ?)`,
          [
            basketData.name,
            basketData.type || 'options',
            totalQuantity,
            totalValue,
            basketData.distributionAlgorithm || 'round-robin',
            basketData.maxBrokers || 1
          ]);

        const basketId = basketResult.insertId;

        // Insert basket items
        for (const item of basketData.items) {
          await query(`INSERT INTO basket_order_items
            (basket_id, symbol, expiry, strike_price, option_type, quantity, order_type, price, trigger_price, transaction_type, product_type, assigned_broker_id)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              basketId,
              item.symbol,
              item.expiry,
              item.strike,
              item.optionType,
              item.quantity,
              item.orderType || 'Market',
              item.price || null,
              item.triggerPrice || null,
              item.transactionType,
              item.productType || 'MIS',
              item.brokerId || null
            ]);
        }

        res.writeHead(201, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          status: true,
          data: {
            id: basketId,
            name: basketData.name,
            status: 'pending',
            totalQuantity,
            totalValue,
            itemsCount: basketData.items.length
          }
        }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // GET /api/basket-orders - Get all basket orders
  if (req.url === '/api/basket-orders' && req.method === 'GET') {
    try {
      const baskets = await query(`
        SELECT bo.*, COUNT(boi.id) as items_count,
               SUM(CASE WHEN boi.status = 'executed' THEN 1 ELSE 0 END) as executed_items,
               SUM(CASE WHEN boi.status = 'failed' THEN 1 ELSE 0 END) as failed_items
        FROM basket_orders bo
        LEFT JOIN basket_order_items boi ON bo.id = boi.basket_id
        GROUP BY bo.id
        ORDER BY bo.created_at DESC
      `);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, data: baskets }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/basket-orders/:id - Get basket order details
  if (req.url.match(/^\/api\/basket-orders\/\d+$/) && req.method === 'GET') {
    const basketId = req.url.split('/')[3];
    try {
      const baskets = await query('SELECT * FROM basket_orders WHERE id = ?', [basketId]);
      if (baskets.length === 0) {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Basket order not found' }));
        return;
      }

      const items = await query(`
        SELECT boi.*, b.name as broker_name, o.order_status as order_status
        FROM basket_order_items boi
        LEFT JOIN brokers b ON boi.assigned_broker_id = b.id
        LEFT JOIN orders o ON boi.order_id = o.id
        WHERE boi.basket_id = ?
        ORDER BY boi.id
      `, [basketId]);

      const executionLogs = await query(`
        SELECT bel.*, b.name as broker_name
        FROM basket_execution_logs bel
        LEFT JOIN brokers b ON bel.broker_id = b.id
        WHERE bel.basket_id = ?
        ORDER BY bel.created_at DESC
      `, [basketId]);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        status: true,
        data: {
          ...baskets[0],
          items,
          executionLogs
        }
      }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // POST /api/basket-orders/:id/execute - Execute basket order
  if (req.url.match(/^\/api\/basket-orders\/\d+\/execute$/) && req.method === 'POST') {
    const basketId = req.url.split('/')[3];
    try {
      // Update basket status to executing
      await query('UPDATE basket_orders SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        ['executing', basketId]);

      // Log execution start
      await query('INSERT INTO basket_execution_logs (basket_id, action, message) VALUES (?, ?, ?)',
        [basketId, 'started', 'Basket execution started']);

      // Get basket items
      const items = await query('SELECT * FROM basket_order_items WHERE basket_id = ? AND status = ?',
        [basketId, 'pending']);

      if (items.length === 0) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'No pending items to execute' }));
        return;
      }

      // Execute basket asynchronously
      brokerManager.executeBasketOrder(basketId, items).catch(error => {
        console.error('Basket execution error:', error);
      });

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        status: true,
        message: 'Basket execution started',
        data: { basketId, itemsToExecute: items.length }
      }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // PUT /api/basket-orders/:id/cancel - Cancel basket order
  if (req.url.match(/^\/api\/basket-orders\/\d+\/cancel$/) && req.method === 'PUT') {
    const basketId = req.url.split('/')[3];
    try {
      await query('UPDATE basket_orders SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        ['cancelled', basketId]);

      await query('UPDATE basket_order_items SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE basket_id = ? AND status IN (?, ?)',
        ['cancelled', basketId, 'pending', 'assigned']);

      await query('INSERT INTO basket_execution_logs (basket_id, action, message) VALUES (?, ?, ?)',
        [basketId, 'cancelled', 'Basket order cancelled by user']);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: true, message: 'Basket order cancelled' }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // GET /api/basket-orders/:id/progress - Get execution progress
  if (req.url.match(/^\/api\/basket-orders\/\d+\/progress$/) && req.method === 'GET') {
    const basketId = req.url.split('/')[3];
    try {
      const progress = await query(`
        SELECT
          COUNT(*) as total_items,
          SUM(CASE WHEN status = 'executed' THEN 1 ELSE 0 END) as executed_items,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_items,
          SUM(CASE WHEN status = 'executing' THEN 1 ELSE 0 END) as executing_items,
          SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_items,
          SUM(CASE WHEN status = 'assigned' THEN 1 ELSE 0 END) as assigned_items
        FROM basket_order_items
        WHERE basket_id = ?
      `, [basketId]);

      const brokerProgress = await query(`
        SELECT
          b.name as broker_name,
          COUNT(boi.id) as total_items,
          SUM(CASE WHEN boi.status = 'executed' THEN 1 ELSE 0 END) as executed_items,
          SUM(CASE WHEN boi.status = 'failed' THEN 1 ELSE 0 END) as failed_items,
          SUM(CASE WHEN boi.status = 'executing' THEN 1 ELSE 0 END) as executing_items
        FROM basket_order_items boi
        LEFT JOIN brokers b ON boi.assigned_broker_id = b.id
        WHERE boi.basket_id = ?
        GROUP BY boi.assigned_broker_id, b.name
      `, [basketId]);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        status: true,
        data: {
          overall: progress[0],
          byBroker: brokerProgress
        }
      }));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // Handle unknown API routes
  res.writeHead(404, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ error: 'API endpoint not found' }));
});

// Start the HTTP server
const PORT = process.env.SERVER_PORT || 3011;
const WS_PORT = process.env.WS_SERVER_PORT || 3001;

server.listen(PORT, '0.0.0.0', async () => {
  console.log(`ðŸŒ Trading server running at http://localhost:${PORT}`);
  console.log(`ðŸ“Š WebSocket server running for client connections`);
  console.log(`ðŸ“± Open http://localhost:${PORT} in your browser to view the dashboard`);

  try {
    // Initialize broker manager and load brokers
    console.log('ðŸ”„ Initializing broker manager...');
    await brokerManager.loadBrokers();
    console.log('âœ… Broker manager initialized successfully');

    // Start position WebSocket server for real-time updates
    console.log('ðŸ”„ Starting position WebSocket server...');
    const wsServer = new PositionWebSocketServer(WS_PORT);
    const wsResult = await wsServer.start();
    if (wsResult.success) {
      console.log(`âœ… Position WebSocket server started on port ${WS_PORT}`);
    } else {
      console.error('âŒ Failed to start position WebSocket server:', wsResult.error);
    }

    // Store WebSocket server reference for cleanup
    global.positionWSServer = wsServer;

    // Start live market feed from AngelOne and forward to PositionWebSocketServer
    try {
      console.log('ðŸ”— Starting AngelOne market feed and forwarding to position WebSocket server');

      // Adapter object expected by subscribeToFeed in smartapi-client.js
      const feedAdapter = {
        clients: [
          {
            // Keep compatible with ws client contract used in smartapi-client
            readyState: WebSocket.OPEN,
            send: (msg) => {
              try {
                const parsed = JSON.parse(msg.toString());
                if (parsed && parsed.type === 'ltp' && parsed.data) {
                  // Forward as a position update (use 'market' channel)
                  // PositionWebSocketServer.broadcastPositionUpdate expects (brokerId, positions)
                  const positions = [parsed.data];
                  if (global.positionWSServer && typeof global.positionWSServer.broadcastPositionUpdate === 'function') {
                    global.positionWSServer.broadcastPositionUpdate('market', positions);
                  }
                }
              } catch (e) {
                console.error('Failed to forward feed message to PositionWebSocketServer:', e.message);
              }
            }
          }
        ]
      };

      // subscribeToFeed will open its own WebSocket to AngelOne and use our adapter to forward messages
      // Pass tokens from environment (recommended) or empty string to trigger error/logging
      const feedConn = subscribeToFeed(feedAdapter, {
        apiKey: process.env.SMARTAPI_API_KEY || process.env.API_KEY || '',
        jwt: process.env.SMARTAPI_JWT || process.env.JWT_TOKEN || '',
        clientCode: process.env.SMARTAPI_CLIENT_CODE || process.env.CLIENT_CODE || '',
        feedToken: process.env.SMARTAPI_FEED_TOKEN || process.env.FEED_TOKEN || ''
      });
      if (feedConn) {
        console.log('âœ… AngelOne feed subscription initiated');
      } else {
        console.error('âŒ AngelOne feed subscription not started due to missing credentials. Set SMARTAPI_FEED_TOKEN and SMARTAPI_API_KEY in environment or backend/.env');
      }
    } catch (e) {
      console.error('âŒ Failed to start AngelOne feed subscription:', e.message);
    }

  } catch (error) {
    console.error('âŒ Error during server initialization:', error);
    process.exit(1);
  }
});

// Test broadcast endpoint - useful for dev environments
server.on('request', (req, res) => {
  try {
    if (req.method === 'POST' && req.url && req.url.startsWith('/api/test/broadcast')) {
      // Accept either query strings or JSON body with { token, symbol, ltp }
      const url = new URL(req.url, `http://${req.headers.host}`)
      const qtoken = url.searchParams.get('token')
      const qsymbol = url.searchParams.get('symbol')
      const qltp = url.searchParams.get('ltp')
      let body = '';
      req.on('data', c => body += c.toString())
      req.on('end', () => {
        try {
          let payload = body ? JSON.parse(body) : {}
          const token = qtoken || payload.token
          const symbol = qsymbol || payload.symbol || `Token_${token}`
          const ltp = qltp || payload.ltp || payload.price || 1000
          if (!global.positionWSServer) {
            res.writeHead(500, {'Content-Type': 'application/json'})
            res.end(JSON.stringify({ error: 'Position WebSocket server not started'}))
            return
          }
          const positions = [{ token: Number(token), symbol, ltp: Number(ltp), timestamp: new Date().toISOString() }]
          global.positionWSServer.broadcastPositionUpdate('market', positions)
          res.writeHead(200, {'Content-Type': 'application/json'})
          res.end(JSON.stringify({ success: true, positions }))
        } catch (e) {
          res.writeHead(400, {'Content-Type': 'application/json'})
          res.end(JSON.stringify({ error: e.message }))
        }
      })
      return
    }
  } catch (e) {
    // ignore
  }
})

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('âŒ Uncaught Exception:', error);
  cleanupWebSocketConnections();
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
  cleanupWebSocketConnections();
  process.exit(1);
});

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Shutting down trading server...');

  // Cleanup WebSocket connections
  cleanupWebSocketConnections();

  // Cleanup position WebSocket server
  if (global.positionWSServer) {
    global.positionWSServer.stop();
  }

  server.close(() => {
    console.log('âœ… Server closed');
    process.exit(0);
  });
});
